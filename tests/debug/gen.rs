// This file is @generated by syn-internal-codegen.
// It is not intended for manual editing.

use super::{Lite, RefCast};
use std::fmt::{self, Debug, Display};
impl Debug for Lite<syn::Abi> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Abi");
        if let Some(val) = &_val.name {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::LitStr);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("name", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::AngleBracketedGenericArguments> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("AngleBracketedGenericArguments");
        if let Some(val) = &_val.colon2_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon2);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("colon2_token", Print::ref_cast(val));
        }
        if !_val.args.is_empty() {
            formatter.field("args", Lite(&_val.args));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::Arm> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Arm");
        formatter.field("pat", Lite(&_val.pat));
        if let Some(val) = &_val.guard {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((syn::token::If, Box<syn::Expr>));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.1), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("guard", Print::ref_cast(val));
        }
        formatter.field("body", Lite(&_val.body));
        if let Some(val) = &_val.comma {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Comma);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("comma", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::BareFnArg> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("BareFnArg");
        if let Some(val) = &_val.name {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((proc_macro2::Ident, syn::token::Colon));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.0), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("name", Print::ref_cast(val));
        }
        formatter.field("ty", Lite(&_val.ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::BinOp> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::BinOp::Add(_val) => {
                formatter.write_str("Add")?;
                Ok(())
            }
            syn::BinOp::Sub(_val) => {
                formatter.write_str("Sub")?;
                Ok(())
            }
            syn::BinOp::Mul(_val) => {
                formatter.write_str("Mul")?;
                Ok(())
            }
            syn::BinOp::Div(_val) => {
                formatter.write_str("Div")?;
                Ok(())
            }
            syn::BinOp::Rem(_val) => {
                formatter.write_str("Rem")?;
                Ok(())
            }
            syn::BinOp::And(_val) => {
                formatter.write_str("And")?;
                Ok(())
            }
            syn::BinOp::Or(_val) => {
                formatter.write_str("Or")?;
                Ok(())
            }
            syn::BinOp::BitXor(_val) => {
                formatter.write_str("BitXor")?;
                Ok(())
            }
            syn::BinOp::BitAnd(_val) => {
                formatter.write_str("BitAnd")?;
                Ok(())
            }
            syn::BinOp::BitOr(_val) => {
                formatter.write_str("BitOr")?;
                Ok(())
            }
            syn::BinOp::Shl(_val) => {
                formatter.write_str("Shl")?;
                Ok(())
            }
            syn::BinOp::Shr(_val) => {
                formatter.write_str("Shr")?;
                Ok(())
            }
            syn::BinOp::Eq(_val) => {
                formatter.write_str("Eq")?;
                Ok(())
            }
            syn::BinOp::Lt(_val) => {
                formatter.write_str("Lt")?;
                Ok(())
            }
            syn::BinOp::Le(_val) => {
                formatter.write_str("Le")?;
                Ok(())
            }
            syn::BinOp::Ne(_val) => {
                formatter.write_str("Ne")?;
                Ok(())
            }
            syn::BinOp::Ge(_val) => {
                formatter.write_str("Ge")?;
                Ok(())
            }
            syn::BinOp::Gt(_val) => {
                formatter.write_str("Gt")?;
                Ok(())
            }
            syn::BinOp::AddEq(_val) => {
                formatter.write_str("AddEq")?;
                Ok(())
            }
            syn::BinOp::SubEq(_val) => {
                formatter.write_str("SubEq")?;
                Ok(())
            }
            syn::BinOp::MulEq(_val) => {
                formatter.write_str("MulEq")?;
                Ok(())
            }
            syn::BinOp::DivEq(_val) => {
                formatter.write_str("DivEq")?;
                Ok(())
            }
            syn::BinOp::RemEq(_val) => {
                formatter.write_str("RemEq")?;
                Ok(())
            }
            syn::BinOp::BitXorEq(_val) => {
                formatter.write_str("BitXorEq")?;
                Ok(())
            }
            syn::BinOp::BitAndEq(_val) => {
                formatter.write_str("BitAndEq")?;
                Ok(())
            }
            syn::BinOp::BitOrEq(_val) => {
                formatter.write_str("BitOrEq")?;
                Ok(())
            }
            syn::BinOp::ShlEq(_val) => {
                formatter.write_str("ShlEq")?;
                Ok(())
            }
            syn::BinOp::ShrEq(_val) => {
                formatter.write_str("ShrEq")?;
                Ok(())
            }
        }
    }
}
impl Debug for Lite<syn::Binding> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Binding");
        formatter.field("ident", Lite(&_val.ident));
        formatter.field("ty", Lite(&_val.ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Block> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Block");
        if !_val.stmts.is_empty() {
            formatter.field("stmts", Lite(&_val.stmts));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::BoundLifetimes> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("BoundLifetimes");
        if !_val.lifetimes.is_empty() {
            formatter.field("lifetimes", Lite(&_val.lifetimes));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ConstParam> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ConstParam");
        formatter.field("ident", Lite(&_val.ident));
        formatter.field("ty", Lite(&_val.ty));
        if let Some(val) = &_val.eq_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Eq);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("eq_token", Print::ref_cast(val));
        }
        if let Some(val) = &_val.default {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Expr);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("default", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::Constraint> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Constraint");
        formatter.field("ident", Lite(&_val.ident));
        if !_val.bounds.is_empty() {
            formatter.field("bounds", Lite(&_val.bounds));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::Expr> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::Expr::Array(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Array");
                if !_val.elems.is_empty() {
                    formatter.field("elems", Lite(&_val.elems));
                }
                formatter.finish()
            }
            syn::Expr::Binary(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Binary");
                formatter.field("left", Lite(&_val.left));
                formatter.field("op", Lite(&_val.op));
                formatter.field("right", Lite(&_val.right));
                formatter.finish()
            }
            syn::Expr::Block(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Block");
                if let Some(val) = &_val.label {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::Label);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("label", Print::ref_cast(val));
                }
                formatter.field("block", Lite(&_val.block));
                formatter.finish()
            }
            syn::Expr::Call(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Call");
                formatter.field("func", Lite(&_val.func));
                if !_val.args.is_empty() {
                    formatter.field("args", Lite(&_val.args));
                }
                formatter.finish()
            }
            syn::Expr::Cast(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Cast");
                formatter.field("expr", Lite(&_val.expr));
                formatter.field("ty", Lite(&_val.ty));
                formatter.finish()
            }
            syn::Expr::Field(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Field");
                formatter.field("base", Lite(&_val.base));
                formatter.field("member", Lite(&_val.member));
                formatter.finish()
            }
            syn::Expr::Group(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Group");
                formatter.field("expr", Lite(&_val.expr));
                formatter.finish()
            }
            syn::Expr::If(_val) => {
                let mut formatter = formatter.debug_struct("Expr::If");
                formatter.field("cond", Lite(&_val.cond));
                formatter.field("then_branch", Lite(&_val.then_branch));
                if let Some(val) = &_val.else_branch {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print((syn::token::Else, Box<syn::Expr>));
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(&_val.1), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("else_branch", Print::ref_cast(val));
                }
                formatter.finish()
            }
            syn::Expr::Index(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Index");
                formatter.field("expr", Lite(&_val.expr));
                formatter.field("index", Lite(&_val.index));
                formatter.finish()
            }
            syn::Expr::Let(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Let");
                formatter.field("pat", Lite(&_val.pat));
                formatter.field("expr", Lite(&_val.expr));
                formatter.finish()
            }
            syn::Expr::Lit(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Lit");
                formatter.field("lit", Lite(&_val.lit));
                formatter.finish()
            }
            syn::Expr::Match(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Match");
                formatter.field("expr", Lite(&_val.expr));
                if !_val.arms.is_empty() {
                    formatter.field("arms", Lite(&_val.arms));
                }
                formatter.finish()
            }
            syn::Expr::MethodCall(_val) => {
                let mut formatter = formatter.debug_struct("Expr::MethodCall");
                formatter.field("receiver", Lite(&_val.receiver));
                formatter.field("method", Lite(&_val.method));
                if let Some(val) = &_val.turbofish {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::MethodTurbofish);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("turbofish", Print::ref_cast(val));
                }
                if !_val.args.is_empty() {
                    formatter.field("args", Lite(&_val.args));
                }
                formatter.finish()
            }
            syn::Expr::Paren(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Paren");
                formatter.field("expr", Lite(&_val.expr));
                formatter.finish()
            }
            syn::Expr::Path(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Path");
                if let Some(val) = &_val.qself {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::QSelf);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("qself", Print::ref_cast(val));
                }
                formatter.field("path", Lite(&_val.path));
                formatter.finish()
            }
            syn::Expr::Range(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Range");
                if let Some(val) = &_val.from {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(Box<syn::Expr>);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("from", Print::ref_cast(val));
                }
                formatter.field("limits", Lite(&_val.limits));
                if let Some(val) = &_val.to {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(Box<syn::Expr>);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("to", Print::ref_cast(val));
                }
                formatter.finish()
            }
            syn::Expr::Reference(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Reference");
                if let Some(val) = &_val.mutability {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Mut);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("mutability", Print::ref_cast(val));
                }
                formatter.field("expr", Lite(&_val.expr));
                formatter.finish()
            }
            syn::Expr::Repeat(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Repeat");
                formatter.field("expr", Lite(&_val.expr));
                formatter.field("len", Lite(&_val.len));
                formatter.finish()
            }
            syn::Expr::Return(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Return");
                if let Some(val) = &_val.expr {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(Box<syn::Expr>);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("expr", Print::ref_cast(val));
                }
                formatter.finish()
            }
            syn::Expr::Struct(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Struct");
                formatter.field("path", Lite(&_val.path));
                if !_val.fields.is_empty() {
                    formatter.field("fields", Lite(&_val.fields));
                }
                if let Some(val) = &_val.dot2_token {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Dot2);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("dot2_token", Print::ref_cast(val));
                }
                if let Some(val) = &_val.rest {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(Box<syn::Expr>);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("rest", Print::ref_cast(val));
                }
                formatter.finish()
            }
            syn::Expr::Tuple(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Tuple");
                if !_val.elems.is_empty() {
                    formatter.field("elems", Lite(&_val.elems));
                }
                formatter.finish()
            }
            syn::Expr::Type(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Type");
                formatter.field("expr", Lite(&_val.expr));
                formatter.field("ty", Lite(&_val.ty));
                formatter.finish()
            }
            syn::Expr::Unary(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Unary");
                formatter.field("op", Lite(&_val.op));
                formatter.field("expr", Lite(&_val.expr));
                formatter.finish()
            }
            syn::Expr::Verbatim(_val) => {
                formatter.write_str("Verbatim")?;
                formatter.write_str("(`")?;
                Display::fmt(_val, formatter)?;
                formatter.write_str("`)")?;
                Ok(())
            }
            _ => unreachable!(),
        }
    }
}
impl Debug for Lite<syn::ExprArray> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprArray");
        if !_val.elems.is_empty() {
            formatter.field("elems", Lite(&_val.elems));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprBinary> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprBinary");
        formatter.field("left", Lite(&_val.left));
        formatter.field("op", Lite(&_val.op));
        formatter.field("right", Lite(&_val.right));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprBlock> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprBlock");
        if let Some(val) = &_val.label {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Label);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("label", Print::ref_cast(val));
        }
        formatter.field("block", Lite(&_val.block));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprCall> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprCall");
        formatter.field("func", Lite(&_val.func));
        if !_val.args.is_empty() {
            formatter.field("args", Lite(&_val.args));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprCast> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprCast");
        formatter.field("expr", Lite(&_val.expr));
        formatter.field("ty", Lite(&_val.ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprField> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprField");
        formatter.field("base", Lite(&_val.base));
        formatter.field("member", Lite(&_val.member));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprGroup> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprGroup");
        formatter.field("expr", Lite(&_val.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprIf> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprIf");
        formatter.field("cond", Lite(&_val.cond));
        formatter.field("then_branch", Lite(&_val.then_branch));
        if let Some(val) = &_val.else_branch {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((syn::token::Else, Box<syn::Expr>));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.1), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("else_branch", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprIndex> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprIndex");
        formatter.field("expr", Lite(&_val.expr));
        formatter.field("index", Lite(&_val.index));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprLet> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprLet");
        formatter.field("pat", Lite(&_val.pat));
        formatter.field("expr", Lite(&_val.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprLit> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprLit");
        formatter.field("lit", Lite(&_val.lit));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprMatch> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprMatch");
        formatter.field("expr", Lite(&_val.expr));
        if !_val.arms.is_empty() {
            formatter.field("arms", Lite(&_val.arms));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprMethodCall> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprMethodCall");
        formatter.field("receiver", Lite(&_val.receiver));
        formatter.field("method", Lite(&_val.method));
        if let Some(val) = &_val.turbofish {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::MethodTurbofish);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("turbofish", Print::ref_cast(val));
        }
        if !_val.args.is_empty() {
            formatter.field("args", Lite(&_val.args));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprParen> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprParen");
        formatter.field("expr", Lite(&_val.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprPath> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprPath");
        if let Some(val) = &_val.qself {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::QSelf);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("qself", Print::ref_cast(val));
        }
        formatter.field("path", Lite(&_val.path));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprRange> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprRange");
        if let Some(val) = &_val.from {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(Box<syn::Expr>);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("from", Print::ref_cast(val));
        }
        formatter.field("limits", Lite(&_val.limits));
        if let Some(val) = &_val.to {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(Box<syn::Expr>);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("to", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprReference> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprReference");
        if let Some(val) = &_val.mutability {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Mut);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("mutability", Print::ref_cast(val));
        }
        formatter.field("expr", Lite(&_val.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprRepeat> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprRepeat");
        formatter.field("expr", Lite(&_val.expr));
        formatter.field("len", Lite(&_val.len));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprReturn> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprReturn");
        if let Some(val) = &_val.expr {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(Box<syn::Expr>);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("expr", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprStruct> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprStruct");
        formatter.field("path", Lite(&_val.path));
        if !_val.fields.is_empty() {
            formatter.field("fields", Lite(&_val.fields));
        }
        if let Some(val) = &_val.dot2_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Dot2);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("dot2_token", Print::ref_cast(val));
        }
        if let Some(val) = &_val.rest {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(Box<syn::Expr>);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("rest", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprTuple> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprTuple");
        if !_val.elems.is_empty() {
            formatter.field("elems", Lite(&_val.elems));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprType> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprType");
        formatter.field("expr", Lite(&_val.expr));
        formatter.field("ty", Lite(&_val.ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprUnary> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprUnary");
        formatter.field("op", Lite(&_val.op));
        formatter.field("expr", Lite(&_val.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::FieldPat> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("FieldPat");
        formatter.field("member", Lite(&_val.member));
        if let Some(val) = &_val.colon_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("colon_token", Print::ref_cast(val));
        }
        formatter.field("pat", Lite(&_val.pat));
        formatter.finish()
    }
}
impl Debug for Lite<syn::FieldValue> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("FieldValue");
        formatter.field("member", Lite(&_val.member));
        if let Some(val) = &_val.colon_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("colon_token", Print::ref_cast(val));
        }
        formatter.field("expr", Lite(&_val.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::GenericArgument> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::GenericArgument::Lifetime(_val) => {
                formatter.write_str("Lifetime")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::GenericArgument::Type(_val) => {
                formatter.write_str("Type")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::GenericArgument::Binding(_val) => {
                formatter.write_str("Binding")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::GenericArgument::Constraint(_val) => {
                formatter.write_str("Constraint")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::GenericArgument::Const(_val) => {
                formatter.write_str("Const")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
        }
    }
}
impl Debug for Lite<syn::GenericMethodArgument> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::GenericMethodArgument::Type(_val) => {
                formatter.write_str("Type")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::GenericMethodArgument::Const(_val) => {
                formatter.write_str("Const")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
        }
    }
}
impl Debug for Lite<syn::GenericParam> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::GenericParam::Type(_val) => {
                formatter.write_str("Type")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::GenericParam::Lifetime(_val) => {
                formatter.write_str("Lifetime")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::GenericParam::Const(_val) => {
                formatter.write_str("Const")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
        }
    }
}
impl Debug for Lite<syn::Generics> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Generics");
        if let Some(val) = &_val.lt_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Lt);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("lt_token", Print::ref_cast(val));
        }
        if !_val.params.is_empty() {
            formatter.field("params", Lite(&_val.params));
        }
        if let Some(val) = &_val.gt_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Gt);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("gt_token", Print::ref_cast(val));
        }
        if let Some(val) = &_val.where_clause {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::WhereClause);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("where_clause", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::Index> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Index");
        formatter.field("index", Lite(&_val.index));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Label> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Label");
        formatter.field("name", Lite(&_val.name));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Lifetime> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Lifetime");
        formatter.field("ident", Lite(&_val.ident));
        formatter.finish()
    }
}
impl Debug for Lite<syn::LifetimeDef> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("LifetimeDef");
        formatter.field("lifetime", Lite(&_val.lifetime));
        if let Some(val) = &_val.colon_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("colon_token", Print::ref_cast(val));
        }
        if !_val.bounds.is_empty() {
            formatter.field("bounds", Lite(&_val.bounds));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::Lit> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::Lit::Str(_val) => write!(formatter, "{:?}", _val.value()),
            syn::Lit::ByteStr(_val) => write!(formatter, "{:?}", _val.value()),
            syn::Lit::Byte(_val) => write!(formatter, "{:?}", _val.value()),
            syn::Lit::Char(_val) => write!(formatter, "{:?}", _val.value()),
            syn::Lit::Int(_val) => write!(formatter, "{}", _val),
            syn::Lit::Float(_val) => write!(formatter, "{}", _val),
            syn::Lit::Bool(_val) => {
                let mut formatter = formatter.debug_struct("Lit::Bool");
                formatter.field("value", Lite(&_val.value));
                formatter.finish()
            }
            syn::Lit::Verbatim(_val) => {
                formatter.write_str("Verbatim")?;
                formatter.write_str("(`")?;
                Display::fmt(_val, formatter)?;
                formatter.write_str("`)")?;
                Ok(())
            }
        }
    }
}
impl Debug for Lite<syn::LitBool> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("LitBool");
        formatter.field("value", Lite(&_val.value));
        formatter.finish()
    }
}
impl Debug for Lite<syn::LitByte> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        write!(formatter, "{:?}", _val.value())
    }
}
impl Debug for Lite<syn::LitByteStr> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        write!(formatter, "{:?}", _val.value())
    }
}
impl Debug for Lite<syn::LitChar> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        write!(formatter, "{:?}", _val.value())
    }
}
impl Debug for Lite<syn::LitFloat> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        write!(formatter, "{}", _val)
    }
}
impl Debug for Lite<syn::LitInt> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        write!(formatter, "{}", _val)
    }
}
impl Debug for Lite<syn::LitStr> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        write!(formatter, "{:?}", _val.value())
    }
}
impl Debug for Lite<syn::Local> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Local");
        formatter.field("pat", Lite(&_val.pat));
        if let Some(val) = &_val.init {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((syn::token::Eq, Box<syn::Expr>));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.1), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("init", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::Member> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::Member::Named(_val) => {
                formatter.write_str("Named")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::Member::Unnamed(_val) => {
                formatter.write_str("Unnamed")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
        }
    }
}
impl Debug for Lite<syn::MethodTurbofish> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("MethodTurbofish");
        if !_val.args.is_empty() {
            formatter.field("args", Lite(&_val.args));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ParenthesizedGenericArguments> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ParenthesizedGenericArguments");
        if !_val.inputs.is_empty() {
            formatter.field("inputs", Lite(&_val.inputs));
        }
        formatter.field("output", Lite(&_val.output));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Pat> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::Pat::Box(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Box");
                formatter.field("pat", Lite(&_val.pat));
                formatter.finish()
            }
            syn::Pat::Ident(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Ident");
                if let Some(val) = &_val.by_ref {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Ref);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("by_ref", Print::ref_cast(val));
                }
                if let Some(val) = &_val.mutability {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Mut);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("mutability", Print::ref_cast(val));
                }
                formatter.field("ident", Lite(&_val.ident));
                if let Some(val) = &_val.subpat {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print((syn::token::At, Box<syn::Pat>));
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(&_val.1), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("subpat", Print::ref_cast(val));
                }
                formatter.finish()
            }
            syn::Pat::Lit(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Lit");
                formatter.field("expr", Lite(&_val.expr));
                formatter.finish()
            }
            syn::Pat::Or(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Or");
                if let Some(val) = &_val.leading_vert {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Or);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("leading_vert", Print::ref_cast(val));
                }
                if !_val.cases.is_empty() {
                    formatter.field("cases", Lite(&_val.cases));
                }
                formatter.finish()
            }
            syn::Pat::Path(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Path");
                if let Some(val) = &_val.qself {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::QSelf);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("qself", Print::ref_cast(val));
                }
                formatter.field("path", Lite(&_val.path));
                formatter.finish()
            }
            syn::Pat::Range(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Range");
                formatter.field("lo", Lite(&_val.lo));
                formatter.field("limits", Lite(&_val.limits));
                formatter.field("hi", Lite(&_val.hi));
                formatter.finish()
            }
            syn::Pat::Reference(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Reference");
                if let Some(val) = &_val.mutability {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Mut);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("mutability", Print::ref_cast(val));
                }
                formatter.field("pat", Lite(&_val.pat));
                formatter.finish()
            }
            syn::Pat::Rest(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Rest");
                formatter.finish()
            }
            syn::Pat::Slice(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Slice");
                if !_val.elems.is_empty() {
                    formatter.field("elems", Lite(&_val.elems));
                }
                formatter.finish()
            }
            syn::Pat::Struct(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Struct");
                formatter.field("path", Lite(&_val.path));
                if !_val.fields.is_empty() {
                    formatter.field("fields", Lite(&_val.fields));
                }
                if let Some(val) = &_val.dot2_token {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Dot2);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("dot2_token", Print::ref_cast(val));
                }
                formatter.finish()
            }
            syn::Pat::Tuple(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Tuple");
                if !_val.elems.is_empty() {
                    formatter.field("elems", Lite(&_val.elems));
                }
                formatter.finish()
            }
            syn::Pat::TupleStruct(_val) => {
                let mut formatter = formatter.debug_struct("Pat::TupleStruct");
                formatter.field("path", Lite(&_val.path));
                formatter.field("pat", Lite(&_val.pat));
                formatter.finish()
            }
            syn::Pat::Type(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Type");
                formatter.field("pat", Lite(&_val.pat));
                formatter.field("ty", Lite(&_val.ty));
                formatter.finish()
            }
            syn::Pat::Verbatim(_val) => {
                formatter.write_str("Verbatim")?;
                formatter.write_str("(`")?;
                Display::fmt(_val, formatter)?;
                formatter.write_str("`)")?;
                Ok(())
            }
            syn::Pat::Wild(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Wild");
                formatter.finish()
            }
            _ => unreachable!(),
        }
    }
}
impl Debug for Lite<syn::PatBox> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatBox");
        formatter.field("pat", Lite(&_val.pat));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatIdent> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatIdent");
        if let Some(val) = &_val.by_ref {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Ref);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("by_ref", Print::ref_cast(val));
        }
        if let Some(val) = &_val.mutability {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Mut);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("mutability", Print::ref_cast(val));
        }
        formatter.field("ident", Lite(&_val.ident));
        if let Some(val) = &_val.subpat {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((syn::token::At, Box<syn::Pat>));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.1), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("subpat", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatLit> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatLit");
        formatter.field("expr", Lite(&_val.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatOr> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatOr");
        if let Some(val) = &_val.leading_vert {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Or);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("leading_vert", Print::ref_cast(val));
        }
        if !_val.cases.is_empty() {
            formatter.field("cases", Lite(&_val.cases));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatPath> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatPath");
        if let Some(val) = &_val.qself {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::QSelf);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("qself", Print::ref_cast(val));
        }
        formatter.field("path", Lite(&_val.path));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatRange> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatRange");
        formatter.field("lo", Lite(&_val.lo));
        formatter.field("limits", Lite(&_val.limits));
        formatter.field("hi", Lite(&_val.hi));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatReference> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatReference");
        if let Some(val) = &_val.mutability {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Mut);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("mutability", Print::ref_cast(val));
        }
        formatter.field("pat", Lite(&_val.pat));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatRest> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatRest");
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatSlice> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatSlice");
        if !_val.elems.is_empty() {
            formatter.field("elems", Lite(&_val.elems));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatStruct> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatStruct");
        formatter.field("path", Lite(&_val.path));
        if !_val.fields.is_empty() {
            formatter.field("fields", Lite(&_val.fields));
        }
        if let Some(val) = &_val.dot2_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Dot2);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("dot2_token", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatTuple> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatTuple");
        if !_val.elems.is_empty() {
            formatter.field("elems", Lite(&_val.elems));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatTupleStruct> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatTupleStruct");
        formatter.field("path", Lite(&_val.path));
        formatter.field("pat", Lite(&_val.pat));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatType> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatType");
        formatter.field("pat", Lite(&_val.pat));
        formatter.field("ty", Lite(&_val.ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatWild> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatWild");
        formatter.finish()
    }
}
impl Debug for Lite<syn::Path> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Path");
        if let Some(val) = &_val.leading_colon {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon2);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("leading_colon", Print::ref_cast(val));
        }
        if !_val.segments.is_empty() {
            formatter.field("segments", Lite(&_val.segments));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::PathArguments> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::PathArguments::None => formatter.write_str("None"),
            syn::PathArguments::AngleBracketed(_val) => {
                let mut formatter = formatter.debug_struct("PathArguments::AngleBracketed");
                if let Some(val) = &_val.colon2_token {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Colon2);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("colon2_token", Print::ref_cast(val));
                }
                if !_val.args.is_empty() {
                    formatter.field("args", Lite(&_val.args));
                }
                formatter.finish()
            }
            syn::PathArguments::Parenthesized(_val) => {
                let mut formatter = formatter.debug_struct("PathArguments::Parenthesized");
                if !_val.inputs.is_empty() {
                    formatter.field("inputs", Lite(&_val.inputs));
                }
                formatter.field("output", Lite(&_val.output));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::PathSegment> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PathSegment");
        formatter.field("ident", Lite(&_val.ident));
        formatter.field("arguments", Lite(&_val.arguments));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PredicateEq> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PredicateEq");
        formatter.field("lhs_ty", Lite(&_val.lhs_ty));
        formatter.field("rhs_ty", Lite(&_val.rhs_ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PredicateLifetime> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PredicateLifetime");
        formatter.field("lifetime", Lite(&_val.lifetime));
        if !_val.bounds.is_empty() {
            formatter.field("bounds", Lite(&_val.bounds));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::PredicateType> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PredicateType");
        if let Some(val) = &_val.lifetimes {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::BoundLifetimes);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("lifetimes", Print::ref_cast(val));
        }
        formatter.field("bounded_ty", Lite(&_val.bounded_ty));
        if !_val.bounds.is_empty() {
            formatter.field("bounds", Lite(&_val.bounds));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::QSelf> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("QSelf");
        formatter.field("ty", Lite(&_val.ty));
        formatter.field("position", Lite(&_val.position));
        if let Some(val) = &_val.as_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::As);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("as_token", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::RangeLimits> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::RangeLimits::HalfOpen(_val) => {
                formatter.write_str("HalfOpen")?;
                Ok(())
            }
            syn::RangeLimits::Closed(_val) => {
                formatter.write_str("Closed")?;
                Ok(())
            }
        }
    }
}
impl Debug for Lite<syn::ReturnType> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::ReturnType::Default => formatter.write_str("Default"),
            syn::ReturnType::Type(_v0, _v1) => {
                let mut formatter = formatter.debug_tuple("Type");
                formatter.field(Lite(_v1));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::Stmt> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::Stmt::Local(_val) => {
                formatter.write_str("Local")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::Stmt::Expr(_val) => {
                formatter.write_str("Expr")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::Stmt::Semi(_v0, _v1) => {
                let mut formatter = formatter.debug_tuple("Semi");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::TraitBound> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TraitBound");
        if let Some(val) = &_val.paren_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Paren);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("paren_token", Print::ref_cast(val));
        }
        formatter.field("modifier", Lite(&_val.modifier));
        if let Some(val) = &_val.lifetimes {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::BoundLifetimes);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("lifetimes", Print::ref_cast(val));
        }
        formatter.field("path", Lite(&_val.path));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TraitBoundModifier> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::TraitBoundModifier::None => formatter.write_str("None"),
            syn::TraitBoundModifier::Maybe(_val) => {
                formatter.write_str("Maybe")?;
                Ok(())
            }
        }
    }
}
impl Debug for Lite<syn::Type> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::Type::Array(_val) => {
                let mut formatter = formatter.debug_struct("Type::Array");
                formatter.field("elem", Lite(&_val.elem));
                formatter.field("len", Lite(&_val.len));
                formatter.finish()
            }
            syn::Type::BareFn(_val) => {
                let mut formatter = formatter.debug_struct("Type::BareFn");
                if let Some(val) = &_val.lifetimes {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::BoundLifetimes);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("lifetimes", Print::ref_cast(val));
                }
                if let Some(val) = &_val.unsafety {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Unsafe);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("unsafety", Print::ref_cast(val));
                }
                if let Some(val) = &_val.abi {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::Abi);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("abi", Print::ref_cast(val));
                }
                if !_val.inputs.is_empty() {
                    formatter.field("inputs", Lite(&_val.inputs));
                }
                if let Some(val) = &_val.variadic {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::Variadic);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("variadic", Print::ref_cast(val));
                }
                formatter.field("output", Lite(&_val.output));
                formatter.finish()
            }
            syn::Type::Group(_val) => {
                let mut formatter = formatter.debug_struct("Type::Group");
                formatter.field("elem", Lite(&_val.elem));
                formatter.finish()
            }
            syn::Type::ImplTrait(_val) => {
                let mut formatter = formatter.debug_struct("Type::ImplTrait");
                if !_val.bounds.is_empty() {
                    formatter.field("bounds", Lite(&_val.bounds));
                }
                formatter.finish()
            }
            syn::Type::Infer(_val) => {
                let mut formatter = formatter.debug_struct("Type::Infer");
                formatter.finish()
            }
            syn::Type::Never(_val) => {
                let mut formatter = formatter.debug_struct("Type::Never");
                formatter.finish()
            }
            syn::Type::Paren(_val) => {
                let mut formatter = formatter.debug_struct("Type::Paren");
                formatter.field("elem", Lite(&_val.elem));
                formatter.finish()
            }
            syn::Type::Path(_val) => {
                let mut formatter = formatter.debug_struct("Type::Path");
                if let Some(val) = &_val.qself {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::QSelf);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("qself", Print::ref_cast(val));
                }
                formatter.field("path", Lite(&_val.path));
                formatter.finish()
            }
            syn::Type::Ptr(_val) => {
                let mut formatter = formatter.debug_struct("Type::Ptr");
                if let Some(val) = &_val.const_token {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Const);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("const_token", Print::ref_cast(val));
                }
                if let Some(val) = &_val.mutability {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Mut);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("mutability", Print::ref_cast(val));
                }
                formatter.field("elem", Lite(&_val.elem));
                formatter.finish()
            }
            syn::Type::Reference(_val) => {
                let mut formatter = formatter.debug_struct("Type::Reference");
                if let Some(val) = &_val.lifetime {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::Lifetime);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("lifetime", Print::ref_cast(val));
                }
                if let Some(val) = &_val.mutability {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Mut);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("mutability", Print::ref_cast(val));
                }
                formatter.field("elem", Lite(&_val.elem));
                formatter.finish()
            }
            syn::Type::Slice(_val) => {
                let mut formatter = formatter.debug_struct("Type::Slice");
                formatter.field("elem", Lite(&_val.elem));
                formatter.finish()
            }
            syn::Type::TraitObject(_val) => {
                let mut formatter = formatter.debug_struct("Type::TraitObject");
                if let Some(val) = &_val.dyn_token {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Dyn);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("dyn_token", Print::ref_cast(val));
                }
                if !_val.bounds.is_empty() {
                    formatter.field("bounds", Lite(&_val.bounds));
                }
                formatter.finish()
            }
            syn::Type::Tuple(_val) => {
                let mut formatter = formatter.debug_struct("Type::Tuple");
                if !_val.elems.is_empty() {
                    formatter.field("elems", Lite(&_val.elems));
                }
                formatter.finish()
            }
            syn::Type::Verbatim(_val) => {
                formatter.write_str("Verbatim")?;
                formatter.write_str("(`")?;
                Display::fmt(_val, formatter)?;
                formatter.write_str("`)")?;
                Ok(())
            }
            _ => unreachable!(),
        }
    }
}
impl Debug for Lite<syn::TypeArray> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypeArray");
        formatter.field("elem", Lite(&_val.elem));
        formatter.field("len", Lite(&_val.len));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeBareFn> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypeBareFn");
        if let Some(val) = &_val.lifetimes {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::BoundLifetimes);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("lifetimes", Print::ref_cast(val));
        }
        if let Some(val) = &_val.unsafety {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Unsafe);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("unsafety", Print::ref_cast(val));
        }
        if let Some(val) = &_val.abi {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Abi);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("abi", Print::ref_cast(val));
        }
        if !_val.inputs.is_empty() {
            formatter.field("inputs", Lite(&_val.inputs));
        }
        if let Some(val) = &_val.variadic {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Variadic);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("variadic", Print::ref_cast(val));
        }
        formatter.field("output", Lite(&_val.output));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeGroup> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypeGroup");
        formatter.field("elem", Lite(&_val.elem));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeImplTrait> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypeImplTrait");
        if !_val.bounds.is_empty() {
            formatter.field("bounds", Lite(&_val.bounds));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeInfer> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypeInfer");
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeNever> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypeNever");
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeParam> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypeParam");
        formatter.field("ident", Lite(&_val.ident));
        if let Some(val) = &_val.colon_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("colon_token", Print::ref_cast(val));
        }
        if !_val.bounds.is_empty() {
            formatter.field("bounds", Lite(&_val.bounds));
        }
        if let Some(val) = &_val.eq_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Eq);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("eq_token", Print::ref_cast(val));
        }
        if let Some(val) = &_val.default {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Type);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("default", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeParamBound> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::TypeParamBound::Trait(_val) => {
                formatter.write_str("Trait")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::TypeParamBound::Lifetime(_val) => {
                formatter.write_str("Lifetime")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
        }
    }
}
impl Debug for Lite<syn::TypeParen> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypeParen");
        formatter.field("elem", Lite(&_val.elem));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypePath> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypePath");
        if let Some(val) = &_val.qself {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::QSelf);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("qself", Print::ref_cast(val));
        }
        formatter.field("path", Lite(&_val.path));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypePtr> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypePtr");
        if let Some(val) = &_val.const_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Const);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("const_token", Print::ref_cast(val));
        }
        if let Some(val) = &_val.mutability {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Mut);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("mutability", Print::ref_cast(val));
        }
        formatter.field("elem", Lite(&_val.elem));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeReference> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypeReference");
        if let Some(val) = &_val.lifetime {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Lifetime);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("lifetime", Print::ref_cast(val));
        }
        if let Some(val) = &_val.mutability {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Mut);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("mutability", Print::ref_cast(val));
        }
        formatter.field("elem", Lite(&_val.elem));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeSlice> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypeSlice");
        formatter.field("elem", Lite(&_val.elem));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeTraitObject> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypeTraitObject");
        if let Some(val) = &_val.dyn_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Dyn);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("dyn_token", Print::ref_cast(val));
        }
        if !_val.bounds.is_empty() {
            formatter.field("bounds", Lite(&_val.bounds));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeTuple> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypeTuple");
        if !_val.elems.is_empty() {
            formatter.field("elems", Lite(&_val.elems));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::UnOp> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::UnOp::Deref(_val) => {
                formatter.write_str("Deref")?;
                Ok(())
            }
            syn::UnOp::Not(_val) => {
                formatter.write_str("Not")?;
                Ok(())
            }
            syn::UnOp::Neg(_val) => {
                formatter.write_str("Neg")?;
                Ok(())
            }
        }
    }
}
impl Debug for Lite<syn::Variadic> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Variadic");
        formatter.finish()
    }
}
impl Debug for Lite<syn::WhereClause> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("WhereClause");
        if !_val.predicates.is_empty() {
            formatter.field("predicates", Lite(&_val.predicates));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::WherePredicate> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::WherePredicate::Type(_val) => {
                formatter.write_str("Type")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::WherePredicate::Lifetime(_val) => {
                formatter.write_str("Lifetime")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::WherePredicate::Eq(_val) => {
                formatter.write_str("Eq")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
        }
    }
}
