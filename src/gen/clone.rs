// This file is @generated by syn-internal-codegen.
// It is not intended for manual editing.

#![allow(clippy::clone_on_copy, clippy::expl_impl_clone_on_copy)]
use crate::*;
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for Abi {
    fn clone(&self) -> Self {
        Abi {
            extern_token: self.extern_token.clone(),
            name: self.name.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for AngleBracketedGenericArguments {
    fn clone(&self) -> Self {
        AngleBracketedGenericArguments {
            colon2_token: self.colon2_token.clone(),
            lt_token: self.lt_token.clone(),
            args: self.args.clone(),
            gt_token: self.gt_token.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for Arm {
    fn clone(&self) -> Self {
        Arm {
            attrs: self.attrs.clone(),
            pat: self.pat.clone(),
            guard: self.guard.clone(),
            fat_arrow_token: self.fat_arrow_token.clone(),
            body: self.body.clone(),
            comma: self.comma.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Copy for AttrStyle {}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for AttrStyle {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for Attribute {
    fn clone(&self) -> Self {
        Attribute {
            pound_token: self.pound_token.clone(),
            style: self.style.clone(),
            bracket_token: self.bracket_token.clone(),
            path: self.path.clone(),
            tokens: self.tokens.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for BareFnArg {
    fn clone(&self) -> Self {
        BareFnArg {
            attrs: self.attrs.clone(),
            name: self.name.clone(),
            ty: self.ty.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Copy for BinOp {}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for BinOp {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for Binding {
    fn clone(&self) -> Self {
        Binding {
            ident: self.ident.clone(),
            eq_token: self.eq_token.clone(),
            ty: self.ty.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for Block {
    fn clone(&self) -> Self {
        Block {
            brace_token: self.brace_token.clone(),
            stmts: self.stmts.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for BoundLifetimes {
    fn clone(&self) -> Self {
        BoundLifetimes {
            for_token: self.for_token.clone(),
            lt_token: self.lt_token.clone(),
            lifetimes: self.lifetimes.clone(),
            gt_token: self.gt_token.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for ConstParam {
    fn clone(&self) -> Self {
        ConstParam {
            attrs: self.attrs.clone(),
            const_token: self.const_token.clone(),
            ident: self.ident.clone(),
            colon_token: self.colon_token.clone(),
            ty: self.ty.clone(),
            eq_token: self.eq_token.clone(),
            default: self.default.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for Constraint {
    fn clone(&self) -> Self {
        Constraint {
            ident: self.ident.clone(),
            colon_token: self.colon_token.clone(),
            bounds: self.bounds.clone(),
        }
    }
}
#[cfg(feature = "derive")]
impl Clone for Data {
    fn clone(&self) -> Self {
        match self {
            Data::Struct(v0) => Data::Struct(v0.clone()),
            Data::Enum(v0) => Data::Enum(v0.clone()),
            Data::Union(v0) => Data::Union(v0.clone()),
        }
    }
}
#[cfg(feature = "derive")]
impl Clone for DataEnum {
    fn clone(&self) -> Self {
        DataEnum {
            enum_token: self.enum_token.clone(),
            brace_token: self.brace_token.clone(),
            variants: self.variants.clone(),
        }
    }
}
#[cfg(feature = "derive")]
impl Clone for DataStruct {
    fn clone(&self) -> Self {
        DataStruct {
            struct_token: self.struct_token.clone(),
            fields: self.fields.clone(),
            semi_token: self.semi_token.clone(),
        }
    }
}
#[cfg(feature = "derive")]
impl Clone for DataUnion {
    fn clone(&self) -> Self {
        DataUnion {
            union_token: self.union_token.clone(),
            fields: self.fields.clone(),
        }
    }
}
#[cfg(feature = "derive")]
impl Clone for DeriveInput {
    fn clone(&self) -> Self {
        DeriveInput {
            attrs: self.attrs.clone(),
            vis: self.vis.clone(),
            ident: self.ident.clone(),
            generics: self.generics.clone(),
            data: self.data.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for Expr {
    fn clone(&self) -> Self {
        match self {
            #[cfg(feature = "full")]
            Expr::Array(v0) => Expr::Array(v0.clone()),
            Expr::Binary(v0) => Expr::Binary(v0.clone()),
            #[cfg(feature = "full")]
            Expr::Block(v0) => Expr::Block(v0.clone()),
            Expr::Call(v0) => Expr::Call(v0.clone()),
            Expr::Cast(v0) => Expr::Cast(v0.clone()),
            Expr::Field(v0) => Expr::Field(v0.clone()),
            #[cfg(feature = "full")]
            Expr::Group(v0) => Expr::Group(v0.clone()),
            #[cfg(feature = "full")]
            Expr::If(v0) => Expr::If(v0.clone()),
            Expr::Index(v0) => Expr::Index(v0.clone()),
            #[cfg(feature = "full")]
            Expr::Let(v0) => Expr::Let(v0.clone()),
            Expr::Lit(v0) => Expr::Lit(v0.clone()),
            #[cfg(feature = "full")]
            Expr::Macro(v0) => Expr::Macro(v0.clone()),
            #[cfg(feature = "full")]
            Expr::Match(v0) => Expr::Match(v0.clone()),
            #[cfg(feature = "full")]
            Expr::MethodCall(v0) => Expr::MethodCall(v0.clone()),
            Expr::Paren(v0) => Expr::Paren(v0.clone()),
            Expr::Path(v0) => Expr::Path(v0.clone()),
            #[cfg(feature = "full")]
            Expr::Range(v0) => Expr::Range(v0.clone()),
            #[cfg(feature = "full")]
            Expr::Reference(v0) => Expr::Reference(v0.clone()),
            #[cfg(feature = "full")]
            Expr::Repeat(v0) => Expr::Repeat(v0.clone()),
            #[cfg(feature = "full")]
            Expr::Return(v0) => Expr::Return(v0.clone()),
            #[cfg(feature = "full")]
            Expr::Struct(v0) => Expr::Struct(v0.clone()),
            #[cfg(feature = "full")]
            Expr::Tuple(v0) => Expr::Tuple(v0.clone()),
            #[cfg(feature = "full")]
            Expr::Type(v0) => Expr::Type(v0.clone()),
            Expr::Unary(v0) => Expr::Unary(v0.clone()),
            Expr::Verbatim(v0) => Expr::Verbatim(v0.clone()),
            _ => unreachable!(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for ExprArray {
    fn clone(&self) -> Self {
        ExprArray {
            attrs: self.attrs.clone(),
            bracket_token: self.bracket_token.clone(),
            elems: self.elems.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for ExprBinary {
    fn clone(&self) -> Self {
        ExprBinary {
            attrs: self.attrs.clone(),
            left: self.left.clone(),
            op: self.op.clone(),
            right: self.right.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for ExprBlock {
    fn clone(&self) -> Self {
        ExprBlock {
            attrs: self.attrs.clone(),
            label: self.label.clone(),
            block: self.block.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for ExprCall {
    fn clone(&self) -> Self {
        ExprCall {
            attrs: self.attrs.clone(),
            func: self.func.clone(),
            paren_token: self.paren_token.clone(),
            args: self.args.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for ExprCast {
    fn clone(&self) -> Self {
        ExprCast {
            attrs: self.attrs.clone(),
            expr: self.expr.clone(),
            as_token: self.as_token.clone(),
            ty: self.ty.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for ExprField {
    fn clone(&self) -> Self {
        ExprField {
            attrs: self.attrs.clone(),
            base: self.base.clone(),
            dot_token: self.dot_token.clone(),
            member: self.member.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for ExprGroup {
    fn clone(&self) -> Self {
        ExprGroup {
            attrs: self.attrs.clone(),
            group_token: self.group_token.clone(),
            expr: self.expr.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for ExprIf {
    fn clone(&self) -> Self {
        ExprIf {
            attrs: self.attrs.clone(),
            if_token: self.if_token.clone(),
            cond: self.cond.clone(),
            then_branch: self.then_branch.clone(),
            else_branch: self.else_branch.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for ExprIndex {
    fn clone(&self) -> Self {
        ExprIndex {
            attrs: self.attrs.clone(),
            expr: self.expr.clone(),
            bracket_token: self.bracket_token.clone(),
            index: self.index.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for ExprLet {
    fn clone(&self) -> Self {
        ExprLet {
            attrs: self.attrs.clone(),
            let_token: self.let_token.clone(),
            pat: self.pat.clone(),
            eq_token: self.eq_token.clone(),
            expr: self.expr.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for ExprLit {
    fn clone(&self) -> Self {
        ExprLit {
            attrs: self.attrs.clone(),
            lit: self.lit.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for ExprMacro {
    fn clone(&self) -> Self {
        ExprMacro {
            attrs: self.attrs.clone(),
            mac: self.mac.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for ExprMatch {
    fn clone(&self) -> Self {
        ExprMatch {
            attrs: self.attrs.clone(),
            match_token: self.match_token.clone(),
            expr: self.expr.clone(),
            brace_token: self.brace_token.clone(),
            arms: self.arms.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for ExprMethodCall {
    fn clone(&self) -> Self {
        ExprMethodCall {
            attrs: self.attrs.clone(),
            receiver: self.receiver.clone(),
            dot_token: self.dot_token.clone(),
            method: self.method.clone(),
            turbofish: self.turbofish.clone(),
            paren_token: self.paren_token.clone(),
            args: self.args.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for ExprParen {
    fn clone(&self) -> Self {
        ExprParen {
            attrs: self.attrs.clone(),
            paren_token: self.paren_token.clone(),
            expr: self.expr.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for ExprPath {
    fn clone(&self) -> Self {
        ExprPath {
            attrs: self.attrs.clone(),
            qself: self.qself.clone(),
            path: self.path.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for ExprRange {
    fn clone(&self) -> Self {
        ExprRange {
            attrs: self.attrs.clone(),
            from: self.from.clone(),
            limits: self.limits.clone(),
            to: self.to.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for ExprReference {
    fn clone(&self) -> Self {
        ExprReference {
            attrs: self.attrs.clone(),
            and_token: self.and_token.clone(),
            raw: self.raw.clone(),
            mutability: self.mutability.clone(),
            expr: self.expr.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for ExprRepeat {
    fn clone(&self) -> Self {
        ExprRepeat {
            attrs: self.attrs.clone(),
            bracket_token: self.bracket_token.clone(),
            expr: self.expr.clone(),
            semi_token: self.semi_token.clone(),
            len: self.len.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for ExprReturn {
    fn clone(&self) -> Self {
        ExprReturn {
            attrs: self.attrs.clone(),
            return_token: self.return_token.clone(),
            expr: self.expr.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for ExprStruct {
    fn clone(&self) -> Self {
        ExprStruct {
            attrs: self.attrs.clone(),
            path: self.path.clone(),
            brace_token: self.brace_token.clone(),
            fields: self.fields.clone(),
            dot2_token: self.dot2_token.clone(),
            rest: self.rest.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for ExprTuple {
    fn clone(&self) -> Self {
        ExprTuple {
            attrs: self.attrs.clone(),
            paren_token: self.paren_token.clone(),
            elems: self.elems.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for ExprType {
    fn clone(&self) -> Self {
        ExprType {
            attrs: self.attrs.clone(),
            expr: self.expr.clone(),
            colon_token: self.colon_token.clone(),
            ty: self.ty.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for ExprUnary {
    fn clone(&self) -> Self {
        ExprUnary {
            attrs: self.attrs.clone(),
            op: self.op.clone(),
            expr: self.expr.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for Field {
    fn clone(&self) -> Self {
        Field {
            attrs: self.attrs.clone(),
            vis: self.vis.clone(),
            ident: self.ident.clone(),
            colon_token: self.colon_token.clone(),
            ty: self.ty.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for FieldPat {
    fn clone(&self) -> Self {
        FieldPat {
            attrs: self.attrs.clone(),
            member: self.member.clone(),
            colon_token: self.colon_token.clone(),
            pat: self.pat.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for FieldValue {
    fn clone(&self) -> Self {
        FieldValue {
            attrs: self.attrs.clone(),
            member: self.member.clone(),
            colon_token: self.colon_token.clone(),
            expr: self.expr.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for Fields {
    fn clone(&self) -> Self {
        match self {
            Fields::Named(v0) => Fields::Named(v0.clone()),
            Fields::Unnamed(v0) => Fields::Unnamed(v0.clone()),
            Fields::Unit => Fields::Unit,
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for FieldsNamed {
    fn clone(&self) -> Self {
        FieldsNamed {
            brace_token: self.brace_token.clone(),
            named: self.named.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for FieldsUnnamed {
    fn clone(&self) -> Self {
        FieldsUnnamed {
            paren_token: self.paren_token.clone(),
            unnamed: self.unnamed.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for GenericArgument {
    fn clone(&self) -> Self {
        match self {
            GenericArgument::Lifetime(v0) => GenericArgument::Lifetime(v0.clone()),
            GenericArgument::Type(v0) => GenericArgument::Type(v0.clone()),
            GenericArgument::Binding(v0) => GenericArgument::Binding(v0.clone()),
            GenericArgument::Constraint(v0) => GenericArgument::Constraint(v0.clone()),
            GenericArgument::Const(v0) => GenericArgument::Const(v0.clone()),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for GenericMethodArgument {
    fn clone(&self) -> Self {
        match self {
            GenericMethodArgument::Type(v0) => GenericMethodArgument::Type(v0.clone()),
            GenericMethodArgument::Const(v0) => GenericMethodArgument::Const(v0.clone()),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for GenericParam {
    fn clone(&self) -> Self {
        match self {
            GenericParam::Type(v0) => GenericParam::Type(v0.clone()),
            GenericParam::Lifetime(v0) => GenericParam::Lifetime(v0.clone()),
            GenericParam::Const(v0) => GenericParam::Const(v0.clone()),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for Generics {
    fn clone(&self) -> Self {
        Generics {
            lt_token: self.lt_token.clone(),
            params: self.params.clone(),
            gt_token: self.gt_token.clone(),
            where_clause: self.where_clause.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for Index {
    fn clone(&self) -> Self {
        Index {
            index: self.index.clone(),
            span: self.span.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for Label {
    fn clone(&self) -> Self {
        Label {
            name: self.name.clone(),
            colon_token: self.colon_token.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for LifetimeDef {
    fn clone(&self) -> Self {
        LifetimeDef {
            attrs: self.attrs.clone(),
            lifetime: self.lifetime.clone(),
            colon_token: self.colon_token.clone(),
            bounds: self.bounds.clone(),
        }
    }
}
impl Clone for Lit {
    fn clone(&self) -> Self {
        match self {
            Lit::Str(v0) => Lit::Str(v0.clone()),
            Lit::ByteStr(v0) => Lit::ByteStr(v0.clone()),
            Lit::Byte(v0) => Lit::Byte(v0.clone()),
            Lit::Char(v0) => Lit::Char(v0.clone()),
            Lit::Int(v0) => Lit::Int(v0.clone()),
            Lit::Float(v0) => Lit::Float(v0.clone()),
            Lit::Bool(v0) => Lit::Bool(v0.clone()),
            Lit::Verbatim(v0) => Lit::Verbatim(v0.clone()),
        }
    }
}
impl Clone for LitBool {
    fn clone(&self) -> Self {
        LitBool {
            value: self.value.clone(),
            span: self.span.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for Local {
    fn clone(&self) -> Self {
        Local {
            attrs: self.attrs.clone(),
            let_token: self.let_token.clone(),
            pat: self.pat.clone(),
            init: self.init.clone(),
            semi_token: self.semi_token.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for Macro {
    fn clone(&self) -> Self {
        Macro {
            path: self.path.clone(),
            bang_token: self.bang_token.clone(),
            delimiter: self.delimiter.clone(),
            tokens: self.tokens.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for MacroDelimiter {
    fn clone(&self) -> Self {
        match self {
            MacroDelimiter::Paren(v0) => MacroDelimiter::Paren(v0.clone()),
            MacroDelimiter::Brace(v0) => MacroDelimiter::Brace(v0.clone()),
            MacroDelimiter::Bracket(v0) => MacroDelimiter::Bracket(v0.clone()),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for Member {
    fn clone(&self) -> Self {
        match self {
            Member::Named(v0) => Member::Named(v0.clone()),
            Member::Unnamed(v0) => Member::Unnamed(v0.clone()),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for Meta {
    fn clone(&self) -> Self {
        match self {
            Meta::Path(v0) => Meta::Path(v0.clone()),
            Meta::List(v0) => Meta::List(v0.clone()),
            Meta::NameValue(v0) => Meta::NameValue(v0.clone()),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for MetaList {
    fn clone(&self) -> Self {
        MetaList {
            path: self.path.clone(),
            paren_token: self.paren_token.clone(),
            nested: self.nested.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for MetaNameValue {
    fn clone(&self) -> Self {
        MetaNameValue {
            path: self.path.clone(),
            eq_token: self.eq_token.clone(),
            lit: self.lit.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for MethodTurbofish {
    fn clone(&self) -> Self {
        MethodTurbofish {
            colon2_token: self.colon2_token.clone(),
            lt_token: self.lt_token.clone(),
            args: self.args.clone(),
            gt_token: self.gt_token.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for NestedMeta {
    fn clone(&self) -> Self {
        match self {
            NestedMeta::Meta(v0) => NestedMeta::Meta(v0.clone()),
            NestedMeta::Lit(v0) => NestedMeta::Lit(v0.clone()),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for ParenthesizedGenericArguments {
    fn clone(&self) -> Self {
        ParenthesizedGenericArguments {
            paren_token: self.paren_token.clone(),
            inputs: self.inputs.clone(),
            output: self.output.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for Pat {
    fn clone(&self) -> Self {
        match self {
            Pat::Box(v0) => Pat::Box(v0.clone()),
            Pat::Ident(v0) => Pat::Ident(v0.clone()),
            Pat::Lit(v0) => Pat::Lit(v0.clone()),
            Pat::Macro(v0) => Pat::Macro(v0.clone()),
            Pat::Or(v0) => Pat::Or(v0.clone()),
            Pat::Path(v0) => Pat::Path(v0.clone()),
            Pat::Range(v0) => Pat::Range(v0.clone()),
            Pat::Reference(v0) => Pat::Reference(v0.clone()),
            Pat::Rest(v0) => Pat::Rest(v0.clone()),
            Pat::Slice(v0) => Pat::Slice(v0.clone()),
            Pat::Struct(v0) => Pat::Struct(v0.clone()),
            Pat::Tuple(v0) => Pat::Tuple(v0.clone()),
            Pat::TupleStruct(v0) => Pat::TupleStruct(v0.clone()),
            Pat::Type(v0) => Pat::Type(v0.clone()),
            Pat::Verbatim(v0) => Pat::Verbatim(v0.clone()),
            Pat::Wild(v0) => Pat::Wild(v0.clone()),
            _ => unreachable!(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for PatBox {
    fn clone(&self) -> Self {
        PatBox {
            attrs: self.attrs.clone(),
            box_token: self.box_token.clone(),
            pat: self.pat.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for PatIdent {
    fn clone(&self) -> Self {
        PatIdent {
            attrs: self.attrs.clone(),
            by_ref: self.by_ref.clone(),
            mutability: self.mutability.clone(),
            ident: self.ident.clone(),
            subpat: self.subpat.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for PatLit {
    fn clone(&self) -> Self {
        PatLit {
            attrs: self.attrs.clone(),
            expr: self.expr.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for PatMacro {
    fn clone(&self) -> Self {
        PatMacro {
            attrs: self.attrs.clone(),
            mac: self.mac.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for PatOr {
    fn clone(&self) -> Self {
        PatOr {
            attrs: self.attrs.clone(),
            leading_vert: self.leading_vert.clone(),
            cases: self.cases.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for PatPath {
    fn clone(&self) -> Self {
        PatPath {
            attrs: self.attrs.clone(),
            qself: self.qself.clone(),
            path: self.path.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for PatRange {
    fn clone(&self) -> Self {
        PatRange {
            attrs: self.attrs.clone(),
            lo: self.lo.clone(),
            limits: self.limits.clone(),
            hi: self.hi.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for PatReference {
    fn clone(&self) -> Self {
        PatReference {
            attrs: self.attrs.clone(),
            and_token: self.and_token.clone(),
            mutability: self.mutability.clone(),
            pat: self.pat.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for PatRest {
    fn clone(&self) -> Self {
        PatRest {
            attrs: self.attrs.clone(),
            dot2_token: self.dot2_token.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for PatSlice {
    fn clone(&self) -> Self {
        PatSlice {
            attrs: self.attrs.clone(),
            bracket_token: self.bracket_token.clone(),
            elems: self.elems.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for PatStruct {
    fn clone(&self) -> Self {
        PatStruct {
            attrs: self.attrs.clone(),
            path: self.path.clone(),
            brace_token: self.brace_token.clone(),
            fields: self.fields.clone(),
            dot2_token: self.dot2_token.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for PatTuple {
    fn clone(&self) -> Self {
        PatTuple {
            attrs: self.attrs.clone(),
            paren_token: self.paren_token.clone(),
            elems: self.elems.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for PatTupleStruct {
    fn clone(&self) -> Self {
        PatTupleStruct {
            attrs: self.attrs.clone(),
            path: self.path.clone(),
            pat: self.pat.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for PatType {
    fn clone(&self) -> Self {
        PatType {
            attrs: self.attrs.clone(),
            pat: self.pat.clone(),
            colon_token: self.colon_token.clone(),
            ty: self.ty.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for PatWild {
    fn clone(&self) -> Self {
        PatWild {
            attrs: self.attrs.clone(),
            underscore_token: self.underscore_token.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for Path {
    fn clone(&self) -> Self {
        Path {
            leading_colon: self.leading_colon.clone(),
            segments: self.segments.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for PathArguments {
    fn clone(&self) -> Self {
        match self {
            PathArguments::None => PathArguments::None,
            PathArguments::AngleBracketed(v0) => PathArguments::AngleBracketed(v0.clone()),
            PathArguments::Parenthesized(v0) => PathArguments::Parenthesized(v0.clone()),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for PathSegment {
    fn clone(&self) -> Self {
        PathSegment {
            ident: self.ident.clone(),
            arguments: self.arguments.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for PredicateEq {
    fn clone(&self) -> Self {
        PredicateEq {
            lhs_ty: self.lhs_ty.clone(),
            eq_token: self.eq_token.clone(),
            rhs_ty: self.rhs_ty.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for PredicateLifetime {
    fn clone(&self) -> Self {
        PredicateLifetime {
            lifetime: self.lifetime.clone(),
            colon_token: self.colon_token.clone(),
            bounds: self.bounds.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for PredicateType {
    fn clone(&self) -> Self {
        PredicateType {
            lifetimes: self.lifetimes.clone(),
            bounded_ty: self.bounded_ty.clone(),
            colon_token: self.colon_token.clone(),
            bounds: self.bounds.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for QSelf {
    fn clone(&self) -> Self {
        QSelf {
            lt_token: self.lt_token.clone(),
            ty: self.ty.clone(),
            position: self.position.clone(),
            as_token: self.as_token.clone(),
            gt_token: self.gt_token.clone(),
        }
    }
}
#[cfg(feature = "full")]
impl Copy for RangeLimits {}
#[cfg(feature = "full")]
impl Clone for RangeLimits {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for ReturnType {
    fn clone(&self) -> Self {
        match self {
            ReturnType::Default => ReturnType::Default,
            ReturnType::Type(v0, v1) => ReturnType::Type(v0.clone(), v1.clone()),
        }
    }
}
#[cfg(feature = "full")]
impl Clone for Stmt {
    fn clone(&self) -> Self {
        match self {
            Stmt::Local(v0) => Stmt::Local(v0.clone()),
            Stmt::Expr(v0) => Stmt::Expr(v0.clone()),
            Stmt::Semi(v0, v1) => Stmt::Semi(v0.clone(), v1.clone()),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for TraitBound {
    fn clone(&self) -> Self {
        TraitBound {
            paren_token: self.paren_token.clone(),
            modifier: self.modifier.clone(),
            lifetimes: self.lifetimes.clone(),
            path: self.path.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Copy for TraitBoundModifier {}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for TraitBoundModifier {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for Type {
    fn clone(&self) -> Self {
        match self {
            Type::Array(v0) => Type::Array(v0.clone()),
            Type::BareFn(v0) => Type::BareFn(v0.clone()),
            Type::Group(v0) => Type::Group(v0.clone()),
            Type::ImplTrait(v0) => Type::ImplTrait(v0.clone()),
            Type::Infer(v0) => Type::Infer(v0.clone()),
            Type::Macro(v0) => Type::Macro(v0.clone()),
            Type::Never(v0) => Type::Never(v0.clone()),
            Type::Paren(v0) => Type::Paren(v0.clone()),
            Type::Path(v0) => Type::Path(v0.clone()),
            Type::Ptr(v0) => Type::Ptr(v0.clone()),
            Type::Reference(v0) => Type::Reference(v0.clone()),
            Type::Slice(v0) => Type::Slice(v0.clone()),
            Type::TraitObject(v0) => Type::TraitObject(v0.clone()),
            Type::Tuple(v0) => Type::Tuple(v0.clone()),
            Type::Verbatim(v0) => Type::Verbatim(v0.clone()),
            _ => unreachable!(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for TypeArray {
    fn clone(&self) -> Self {
        TypeArray {
            bracket_token: self.bracket_token.clone(),
            elem: self.elem.clone(),
            semi_token: self.semi_token.clone(),
            len: self.len.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for TypeBareFn {
    fn clone(&self) -> Self {
        TypeBareFn {
            lifetimes: self.lifetimes.clone(),
            unsafety: self.unsafety.clone(),
            abi: self.abi.clone(),
            fn_token: self.fn_token.clone(),
            paren_token: self.paren_token.clone(),
            inputs: self.inputs.clone(),
            variadic: self.variadic.clone(),
            output: self.output.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for TypeGroup {
    fn clone(&self) -> Self {
        TypeGroup {
            group_token: self.group_token.clone(),
            elem: self.elem.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for TypeImplTrait {
    fn clone(&self) -> Self {
        TypeImplTrait {
            impl_token: self.impl_token.clone(),
            bounds: self.bounds.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for TypeInfer {
    fn clone(&self) -> Self {
        TypeInfer {
            underscore_token: self.underscore_token.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for TypeMacro {
    fn clone(&self) -> Self {
        TypeMacro {
            mac: self.mac.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for TypeNever {
    fn clone(&self) -> Self {
        TypeNever {
            bang_token: self.bang_token.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for TypeParam {
    fn clone(&self) -> Self {
        TypeParam {
            attrs: self.attrs.clone(),
            ident: self.ident.clone(),
            colon_token: self.colon_token.clone(),
            bounds: self.bounds.clone(),
            eq_token: self.eq_token.clone(),
            default: self.default.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for TypeParamBound {
    fn clone(&self) -> Self {
        match self {
            TypeParamBound::Trait(v0) => TypeParamBound::Trait(v0.clone()),
            TypeParamBound::Lifetime(v0) => TypeParamBound::Lifetime(v0.clone()),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for TypeParen {
    fn clone(&self) -> Self {
        TypeParen {
            paren_token: self.paren_token.clone(),
            elem: self.elem.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for TypePath {
    fn clone(&self) -> Self {
        TypePath {
            qself: self.qself.clone(),
            path: self.path.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for TypePtr {
    fn clone(&self) -> Self {
        TypePtr {
            star_token: self.star_token.clone(),
            const_token: self.const_token.clone(),
            mutability: self.mutability.clone(),
            elem: self.elem.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for TypeReference {
    fn clone(&self) -> Self {
        TypeReference {
            and_token: self.and_token.clone(),
            lifetime: self.lifetime.clone(),
            mutability: self.mutability.clone(),
            elem: self.elem.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for TypeSlice {
    fn clone(&self) -> Self {
        TypeSlice {
            bracket_token: self.bracket_token.clone(),
            elem: self.elem.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for TypeTraitObject {
    fn clone(&self) -> Self {
        TypeTraitObject {
            dyn_token: self.dyn_token.clone(),
            bounds: self.bounds.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for TypeTuple {
    fn clone(&self) -> Self {
        TypeTuple {
            paren_token: self.paren_token.clone(),
            elems: self.elems.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Copy for UnOp {}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for UnOp {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for Variadic {
    fn clone(&self) -> Self {
        Variadic {
            attrs: self.attrs.clone(),
            dots: self.dots.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for Variant {
    fn clone(&self) -> Self {
        Variant {
            attrs: self.attrs.clone(),
            ident: self.ident.clone(),
            fields: self.fields.clone(),
            discriminant: self.discriminant.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for VisCrate {
    fn clone(&self) -> Self {
        VisCrate {
            crate_token: self.crate_token.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for VisPublic {
    fn clone(&self) -> Self {
        VisPublic {
            pub_token: self.pub_token.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for VisRestricted {
    fn clone(&self) -> Self {
        VisRestricted {
            pub_token: self.pub_token.clone(),
            paren_token: self.paren_token.clone(),
            in_token: self.in_token.clone(),
            path: self.path.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for Visibility {
    fn clone(&self) -> Self {
        match self {
            Visibility::Public(v0) => Visibility::Public(v0.clone()),
            Visibility::Crate(v0) => Visibility::Crate(v0.clone()),
            Visibility::Restricted(v0) => Visibility::Restricted(v0.clone()),
            Visibility::Inherited => Visibility::Inherited,
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for WhereClause {
    fn clone(&self) -> Self {
        WhereClause {
            where_token: self.where_token.clone(),
            predicates: self.predicates.clone(),
        }
    }
}
#[cfg(any(feature = "derive", feature = "full"))]
impl Clone for WherePredicate {
    fn clone(&self) -> Self {
        match self {
            WherePredicate::Type(v0) => WherePredicate::Type(v0.clone()),
            WherePredicate::Lifetime(v0) => WherePredicate::Lifetime(v0.clone()),
            WherePredicate::Eq(v0) => WherePredicate::Eq(v0.clone()),
        }
    }
}
